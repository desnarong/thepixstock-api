# Event Photo Sales - Phase 2: Face Recognition & Advanced Features

## ü§ñ **Phase 2: Face Recognition System**

### **app/models/face.py - Face Recognition Models**
```python
from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, ForeignKey, DECIMAL, Enum, Index
from sqlalchemy.orm import relationship
from app.database import Base
from datetime import datetime
import enum

class FaceDetectionStatus(enum.Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"

class FaceQuality(enum.Enum):
    EXCELLENT = "excellent"  # 0.9+
    GOOD = "good"           # 0.7-0.9
    FAIR = "fair"           # 0.5-0.7
    POOR = "poor"           # <0.5

class Face(Base):
    __tablename__ = "faces"
    
    id = Column(Integer, primary_key=True, index=True)
    photo_id = Column(Integer, ForeignKey("photos.id"), nullable=False, index=True)
    
    # Face encoding data
    face_encoding = Column(Text, nullable=False)  # JSON array of 128 dimensions
    face_hash = Column(String(64), index=True)    # Hash for quick comparison
    
    # Face location in photo
    bounding_box = Column(Text, nullable=False)   # JSON: {top, right, bottom, left}
    face_landmarks = Column(Text)                 # JSON: facial landmarks (68 points)
    
    # Quality metrics
    confidence = Column(DECIMAL(5,4), nullable=False)  # Detection confidence 0.0000-1.0000
    quality_score = Column(DECIMAL(5,4))              # Face quality assessment
    quality_rating = Column(Enum(FaceQuality))       # Categorical quality rating
    
    # Face characteristics
    estimated_age = Column(Integer)
    estimated_gender = Column(String(10))  # male, female, unknown
    emotions = Column(Text)                # JSON: emotion scores
    
    # Processing metadata
    detection_model = Column(String(50))   # Model version used
    detection_confidence = Column(DECIMAL(5,4))
    processing_time_ms = Column(Integer)   # Processing time in milliseconds
    
    # Grouping
    face_group_id = Column(Integer, ForeignKey("face_groups.id"), index=True)
    is_representative = Column(Boolean, default=False)  # Best face for this person
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    photo = relationship("Photo", back_populates="faces")
    face_group = relationship("FaceGroup", back_populates="faces")
    search_results = relationship("FaceSearchResult", back_populates="face")
    
    # Indexes for performance
    __table_args__ = (
        Index('idx_face_photo_confidence', 'photo_id', 'confidence'),
        Index('idx_face_quality', 'quality_score'),
        Index('idx_face_created', 'created_at'),
    )

class FaceGroup(Base):
    __tablename__ = "face_groups"
    
    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"), nullable=False, index=True)
    
    # Group information
    representative_face_id = Column(Integer, ForeignKey("faces.id"))
    face_count = Column(Integer, default=0)
    avg_confidence = Column(DECIMAL(5,4))
    
    # Manual verification
    is_verified = Column(Boolean, default=False)
    verified_by = Column(Integer, ForeignKey("users.id"))
    verified_at = Column(DateTime)
    
    # Optional naming
    group_name = Column(String(255))      # Optional person name
    notes = Column(Text)                  # Admin notes
    
    # Quality metrics
    best_quality_score = Column(DECIMAL(5,4))
    worst_quality_score = Column(DECIMAL(5,4))
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    event = relationship("Event")
    faces = relationship("Face", back_populates="face_group", foreign_keys="Face.face_group_id")
    representative_face = relationship("Face", foreign_keys=[representative_face_id])
    verified_by_user = relationship("User", foreign_keys=[verified_by])

class FaceSearch(Base):
    __tablename__ = "face_searches"
    
    id = Column(Integer, primary_key=True, index=True)
    customer_id = Column(Integer, ForeignKey("customers.id"), index=True)  # Can be anonymous
    event_id = Column(Integer, ForeignKey("events.id"), nullable=False, index=True)
    
    # Search image data
    search_image_path = Column(String(500), nullable=False)
    search_encoding = Column(Text, nullable=False)  # Face encoding for search
    search_image_hash = Column(String(64))
    
    # Search parameters
    similarity_threshold = Column(DECIMAL(5,4), default=0.6)  # Minimum similarity for match
    max_results = Column(Integer, default=50)
    
    # Search results
    total_matches = Column(Integer, default=0)
    best_match_similarity = Column(DECIMAL(5,4))
    
    # Search status
    search_status = Column(Enum(FaceDetectionStatus), default=FaceDetectionStatus.PENDING, index=True)
    processing_time_seconds = Column(Integer)
    error_message = Column(Text)
    
    # Session tracking
    session_id = Column(String(255), index=True)  # For anonymous users
    ip_address = Column(String(45))
    user_agent = Column(Text)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    completed_at = Column(DateTime)
    
    # Relationships
    customer = relationship("Customer", back_populates="face_searches")
    event = relationship("Event")
    results = relationship("FaceSearchResult", back_populates="search", cascade="all, delete-orphan")

class FaceSearchResult(Base):
    __tablename__ = "face_search_results"
    
    id = Column(Integer, primary_key=True)
    search_id = Column(Integer, ForeignKey("face_searches.id"), nullable=False, index=True)
    photo_id = Column(Integer, ForeignKey("photos.id"), nullable=False, index=True)
    face_id = Column(Integer, ForeignKey("faces.id"), nullable=False, index=True)
    
    # Similarity metrics
    similarity_score = Column(DECIMAL(5,4), nullable=False, index=True)  # 0.0000-1.0000
    confidence_score = Column(DECIMAL(5,4), nullable=False)
    distance_score = Column(DECIMAL(8,6))  # Face distance metric
    
    # Face location in result photo
    face_bounding_box = Column(Text)  # JSON: face location
    
    # Customer feedback
    customer_feedback = Column(Enum(enum.Enum('Feedback', 'correct incorrect unsure')))
    feedback_at = Column(DateTime)
    feedback_notes = Column(Text)
    
    # Result ranking
    rank_order = Column(Integer)  # 1 = best match
    is_shown_to_customer = Column(Boolean, default=True)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    search = relationship("FaceSearch", back_populates="results")
    photo = relationship("Photo")
    face = relationship("Face", back_populates="search_results")
    
    # Indexes
    __table_args__ = (
        Index('idx_search_similarity', 'search_id', 'similarity_score'),
        Index('idx_search_rank', 'search_id', 'rank_order'),
    )

class FaceProcessingJob(Base):
    __tablename__ = "face_processing_jobs"
    
    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"), index=True)
    photo_id = Column(Integer, ForeignKey("photos.id"), index=True)
    
    job_type = Column(String(50), nullable=False)  # detect_faces, group_faces, train_model
    status = Column(Enum(FaceDetectionStatus), default=FaceDetectionStatus.PENDING, index=True)
    priority = Column(Integer, default=5)  # 1-10, 1 is highest
    
    # Processing details
    job_data = Column(Text)     # JSON: job parameters
    result_data = Column(Text)  # JSON: job results
    error_message = Column(Text)
    
    # Progress tracking
    progress_percentage = Column(Integer, default=0)
    faces_detected = Column(Integer, default=0)
    faces_processed = Column(Integer, default=0)
    
    # Performance metrics
    processing_time_seconds = Column(Integer)
    cpu_time_seconds = Column(DECIMAL(8,3))
    memory_used_mb = Column(Integer)
    
    # Retry logic
    attempts = Column(Integer, default=0)
    max_attempts = Column(Integer, default=3)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    started_at = Column(DateTime)
    completed_at = Column(DateTime)
    
    # Relationships
    event = relationship("Event")
    photo = relationship("Photo")
```

---

### **app/api/face_recognition.py - Face Recognition APIs**
```python
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from sqlalchemy.orm import Session
from typing import List, Optional
from app.database import get_db
from app.models.user import User
from app.models.face import FaceSearch, FaceSearchResult, Face, FaceGroup
from app.services.face_recognition_service import FaceRecognitionService
from app.schemas.face import FaceSearchCreate, FaceSearchResponse, FaceGroupResponse

router = APIRouter()

# Admin APIs for Face Detection Management
@router.post("/detect/event/{event_id}")
async def detect_faces_in_event(
    event_id: int,
    force_reprocess: bool = False,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Start face detection for all photos in event (Admin only)"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    face_service = FaceRecognitionService(db)
    
    try:
        job = await face_service.start_event_face_detection(
            event_id=event_id,
            force_reprocess=force_reprocess
        )
        
        return {
            "message": "Face detection started",
            "job_id": job.id,
            "estimated_time_minutes": job.estimated_time_minutes,
            "status": job.status.value
        }
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/detect/status/{event_id}")
async def get_face_detection_status(
    event_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get face detection status for event"""
    face_service = FaceRecognitionService(db)
    status = face_service.get_event_face_detection_status(event_id)
    
    return {
        "event_id": event_id,
        "status": status["status"],
        "progress_percentage": status["progress"],
        "faces_detected": status["faces_detected"],
        "photos_processed": status["photos_processed"],
        "total_photos": status["total_photos"],
        "estimated_completion": status["estimated_completion"]
    }

@router.get("/groups/event/{event_id}", response_model=List[FaceGroupResponse])
async def get_event_face_groups(
    event_id: int,
    skip: int = 0,
    limit: int = 100,
    verified_only: bool = False,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get face groups for event (Admin only)"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    face_service = FaceRecognitionService(db)
    groups = face_service.get_event_face_groups(
        event_id=event_id,
        skip=skip,
        limit=limit,
        verified_only=verified_only
    )
    
    return groups

@router.post("/groups/{group_id}/verify")
async def verify_face_group(
    group_id: int,
    verified: bool,
    group_name: Optional[str] = None,
    notes: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Verify that faces in group belong to same person (Admin only)"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    face_service = FaceRecognitionService(db)
    result = face_service.verify_face_group(
        group_id=group_id,
        verified=verified,
        group_name=group_name,
        notes=notes,
        verified_by=current_user.id
    )
    
    if not result:
        raise HTTPException(status_code=404, detail="Face group not found")
    
    return {"message": "Face group verification updated"}

@router.post("/groups/merge")
async def merge_face_groups(
    source_group_id: int,
    target_group_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Merge two face groups (Admin only)"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    face_service = FaceRecognitionService(db)
    result = face_service.merge_face_groups(source_group_id, target_group_id)
    
    if not result:
        raise HTTPException(status_code=400, detail="Cannot merge face groups")
    
    return {"message": "Face groups merged successfully"}

# Public/Customer APIs for Face Search
@router.post("/search/{event_id}")
async def search_faces_by_photo(
    event_id: int,
    search_image: UploadFile = File(...),
    similarity_threshold: float = 0.6,
    max_results: int = 50,
    customer_id: Optional[int] = None,
    session_id: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Search for faces in event using uploaded photo (Public API)"""
    
    # Validate file
    if not search_image.content_type.startswith('image/'):
        raise HTTPException(status_code=400, detail="File must be an image")
    
    if search_image.size > 10 * 1024 * 1024:  # 10MB limit
        raise HTTPException(status_code=400, detail="Image too large (max 10MB)")
    
    face_service = FaceRecognitionService(db)
    
    try:
        search = await face_service.search_faces_by_photo(
            event_id=event_id,
            search_image=search_image,
            customer_id=customer_id,
            session_id=session_id,
            similarity_threshold=similarity_threshold,
            max_results=max_results
        )
        
        return {
            "search_id": search.id,
            "status": search.search_status.value,
            "message": "Face search initiated",
            "estimated_time_seconds": 30
        }
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/search/{search_id}/results")
async def get_search_results(
    search_id: int,
    skip: int = 0,
    limit: int = 20,
    min_similarity: float = 0.5,
    db: Session = Depends(get_db)
):
    """Get face search results"""
    face_service = FaceRecognitionService(db)
    
    search = face_service.get_face_search(search_id)
    if not search:
        raise HTTPException(status_code=404, detail="Search not found")
    
    if search.search_status == "processing":
        return {
            "search_id": search_id,
            "status": "processing",
            "progress": "Face search is still processing...",
            "results": []
        }
    
    results = face_service.get_search_results(
        search_id=search_id,
        skip=skip,
        limit=limit,
        min_similarity=min_similarity
    )
    
    return {
        "search_id": search_id,
        "status": search.search_status.value,
        "total_matches": search.total_matches,
        "best_match_similarity": float(search.best_match_similarity) if search.best_match_similarity else 0,
        "results": [
            {
                "photo_id": r.photo_id,
                "similarity_score": float(r.similarity_score),
                "confidence_score": float(r.confidence_score),
                "photo_thumbnail": f"/api/photos/{r.photo_id}/download/thumbnail",
                "photo_preview": f"/api/photos/{r.photo_id}/download/preview",
                "face_bounding_box": r.face_bounding_box,
                "rank": r.rank_order
            }
            for r in results
        ]
    }

@router.post("/search/{search_id}/feedback")
async def submit_search_feedback(
    search_id: int,
    photo_id: int,
    feedback: str,  # "correct", "incorrect", "unsure"
    notes: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Submit feedback on search results"""
    if feedback not in ["correct", "incorrect", "unsure"]:
        raise HTTPException(status_code=400, detail="Invalid feedback value")
    
    face_service = FaceRecognitionService(db)
    result = face_service.submit_search_feedback(
        search_id=search_id,
        photo_id=photo_id,
        feedback=feedback,
        notes=notes
    )
    
    if not result:
        raise HTTPException(status_code=404, detail="Search result not found")
    
    return {"message": "Feedback submitted successfully"}

@router.get("/search/history")
async def get_search_history(
    customer_id: Optional[int] = None,
    session_id: Optional[str] = None,
    skip: int = 0,
    limit: int = 10,
    db: Session = Depends(get_db)
):
    """Get search history for customer or session"""
    if not customer_id and not session_id:
        raise HTTPException(status_code=400, detail="Customer ID or session ID required")
    
    face_service = FaceRecognitionService(db)
    searches = face_service.get_search_history(
        customer_id=customer_id,
        session_id=session_id,
        skip=skip,
        limit=limit
    )
    
    return {
        "searches": [
            {
                "search_id": s.id,
                "event_id": s.event_id,
                "total_matches": s.total_matches,
                "best_match_similarity": float(s.best_match_similarity) if s.best_match_similarity else 0,
                "status": s.search_status.value,
                "created_at": s.created_at.isoformat()
            }
            for s in searches
        ]
    }

@router.get("/analytics/event/{event_id}")
async def get_face_recognition_analytics(
    event_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get face recognition analytics for event (Admin only)"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    face_service = FaceRecognitionService(db)
    analytics = face_service.get_event_face_analytics(event_id)
    
    return {
        "event_id": event_id,
        "total_faces_detected": analytics["total_faces"],
        "total_face_groups": analytics["total_groups"],
        "verified_groups": analytics["verified_groups"],
        "average_faces_per_photo": analytics["avg_faces_per_photo"],
        "face_quality_distribution": analytics["quality_distribution"],
        "total_searches": analytics["total_searches"],
        "successful_searches": analytics["successful_searches"],
        "search_success_rate": analytics["search_success_rate"],
        "popular_search_times": analytics["popular_search_times"]
    }
```

---

### **app/services/face_recognition_service.py - Face Recognition Business Logic**
```python
import httpx
import json
import hashlib
import numpy as np
from sqlalchemy.orm import Session
from sqlalchemy import and_, func
from app.models.face import Face, FaceGroup, FaceSearch, FaceSearchResult, FaceProcessingJob, FaceDetectionStatus
from app.models.photo import Photo
from app.models.event import Event
from app.services.storage_service import StorageService
from app.config import settings
from fastapi import UploadFile
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import uuid

class FaceRecognitionService:
    def __init__(self, db: Session):
        self.db = db
        self.storage_service = StorageService()
        self.ai_process_url = settings.AI_PROCESS_URL
    
    async def start_event_face_detection(
        self, 
        event_id: int, 
        force_reprocess: bool = False
    ) -> FaceProcessingJob:
        """Start face detection for all photos in an event"""
        
        # Check if event exists
        event = self.db.query(Event).filter(Event.id == event_id).first()
        if not event:
            raise ValueError("Event not found")
        
        # Get photos that need face detection
        query = self.db.query(Photo).filter(
            Photo.event_id == event_id,
            Photo.approval_status == "approved"
        )
        
        if not force_reprocess:
            query = query.filter(Photo.face_detection_status == "pending")
        
        photos = query.all()
        
        if not photos:
            raise ValueError("No photos need face detection")
        
        # Create processing job
        job = FaceProcessingJob(
            event_id=event_id,
            job_type="detect_faces",
            status=FaceDetectionStatus.PENDING,
            job_data=json.dumps({
                "photo_count": len(photos),
                "force_reprocess": force_reprocess
            })
        )
        
        self.db.add(job)
        self.db.flush()
        
        # Start processing in background
        await self._process_face_detection_job(job.id, photos)
        
        self.db.commit()
        return job
    
    async def _process_face_detection_job(self, job_id: int, photos: List[Photo]):
        """Process face detection for a batch of photos"""
        job = self.db.query(FaceProcessingJob).filter(FaceProcessingJob.id == job_id).first()
        
        try:
            job.status = FaceDetectionStatus.PROCESSING
            job.started_at = datetime.utcnow()
            self.db.commit()
            
            total_photos = len(photos)
            processed_photos = 0
            total_faces_detected = 0
            
            for photo in photos:
                try:
                    # Get photo URL for AI processing
                    photo_url = self.storage_service.get_download_url(
                        photo.id, 
                        "full", 
                        expires=3600
                    )
                    
                    # Call AI service
                    faces_data = await self._call_ai_face_detection(photo_url, photo.id)
                    
                    # Save detected faces
                    face_count = await self._save_detected_faces(photo.id, faces_data)
                    total_faces_detected += face_count
                    
                    # Update photo status
                    photo.face_detection_status = "completed"
                    photo.face_count = face_count
                    photo.face_detection_completed_at = datetime.utcnow()
                    
                except Exception as e:
                    print(f"Error processing photo {photo.id}: {e}")
                    photo.face_detection_status = "failed"
                
                processed_photos += 1
                
                # Update job progress
                job.progress_percentage = int((processed_photos / total_photos) * 100)
                job.faces_detected = total_faces_detected
                job.faces_processed = processed_photos
                
                self.db.commit()
            
            # Complete job
            job.status = FaceDetectionStatus.COMPLETED
            job.completed_at = datetime.utcnow()
            job.processing_time_seconds = int(
                (job.completed_at - job.started_at).total_seconds()
            )
            
            # Update event status
            event = self.db.query(Event).filter(Event.id == job.event_id).first()
            if event:
                event.face_detection_completed = True
            
            # Start face grouping
            await self._start_face_grouping(job.event_id)
            
        except Exception as e:
            job.status = FaceDetectionStatus.FAILED
            job.error_message = str(e)
        
        finally:
            self.db.commit()
    
    async def _call_ai_face_detection(self, photo_url: str, photo_id: int) -> List[Dict]:
        """Call external AI service for face detection"""
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    self.ai_process_url,
                    json={
                        "image_url": photo_url,
                        "photo_id": photo_id,
                        "return_landmarks": True,
                        "return_emotions": True,
                        "min_confidence": 0.5
                    },
                    timeout=60.0
                )
                
                if response.status_code == 200:
                    result = response.json()
                    return result.get("faces", [])
                else:
                    raise Exception(f"AI service error: {response.status_code}")
                    
            except httpx.TimeoutException:
                raise Exception("AI service timeout")
            except Exception as e:
                raise Exception(f"AI service call failed: {e}")
    
    async def _save_detected_faces(self, photo_id: int, faces_data: List[Dict]) -> int:
        """Save detected faces to database"""
        face_count = 0
        
        for face_data in faces_data:
            try:
                # Create face encoding hash for quick comparison
                encoding = face_data.get("encoding", [])
                face_hash = hashlib.md5(json.dumps(encoding).encode()).hexdigest()
                
                face = Face(
                    photo_id=photo_id,
                    face_encoding=json.dumps(encoding),
                    face_hash=face_hash,
                    bounding_box=json.dumps(face_data.get("bounding_box", {})),
                    face_landmarks=json.dumps(face_data.get("landmarks", {})),
                    confidence=face_data.get("confidence", 0.0),
                    quality_score=face_data.get("quality_score", 0.0),
                    estimated_age=face_data.get("estimated_age"),
                    estimated_gender=face_data.get("estimated_gender"),
                    emotions=json.dumps(face_data.get("emotions", {})),
                    detection_model=face_data.get("model_version", "default"),
                    processing_time_ms=face_data.get("processing_time_ms", 0)
                )
                
                # Set quality rating based on score
                if face.quality_score >= 0.9:
                    face.quality_rating = "excellent"
                elif face.quality_score >= 0.7:
                    face.quality_rating = "good"
                elif face.quality_score >= 0.5:
                    face.quality_rating = "fair"
                else:
                    face.quality_rating = "poor"
                
                self.db.add(face)
                face_count += 1
                
            except Exception as e:
                print(f"Error saving face data: {e}")
                continue
        
        return face_count
    
    async def _start_face_grouping(self, event_id: int):
        """Group similar faces together"""
        # Get all faces for the event
        faces = self.db.query(Face).join(Photo).filter(
            Photo.event_id == event_id,
            Face.face_group_id.is_(None),  # Not yet grouped
            Face.quality_score >= 0.5      # Minimum quality
        ).all()
        
        if len(faces) < 2:
            return
        
        # Simple clustering based on face encoding similarity
        face_groups = []
        processed_faces = set()
        
        for face in faces:
            if face.id in processed_faces:
                continue
            
            # Create new group
            group = FaceGroup(
                event_id=event_id,
                representative_face_id=face.id,
                face_count=1,
                avg_confidence=face.confidence,
                best_quality_score=face.quality_score,
                worst_quality_score=face.quality_score
            )
            
            self.db.add(group)
            self.db.flush()
            
            # Add face to group
            face.face_group_id = group.id
            face.is_representative = True
            processed_faces.add(face.id)
            
            # Find similar faces
            similar_faces = self._find_similar_faces(face, faces, processed_faces)
            
            for similar_face in similar_faces:
                similar_face.face_group_id = group.id
                processed_faces.add(similar_face.id)
                
                # Update group stats
                group.face_count += 1
                group.avg_confidence = (group.avg_confidence + similar_face.confidence) / 2
                group.best_quality_score = max(group.best_quality_score, similar_face.quality_score)
                group.worst_quality_score = min(group.worst_quality_score, similar_face.quality_score)
        
        self.db.commit()
    
    def _find_similar_faces(self, target_face: Face, all_faces: List[Face], processed: set) -> List[Face]:
        """Find faces similar to target face using encoding comparison"""
        similar_faces = []
        target_encoding = np.array(json.loads(target_face.face_encoding))
        
        for face in all_faces:
            if face.id in processed or face.id == target_face.id:
                continue
            
            try:
                face_encoding = np.array(json.loads(face.face_encoding))
                
                # Calculate cosine similarity
                similarity = np.dot(target_encoding, face_encoding) / (
                    np.linalg.norm(target_encoding) * np.linalg.norm(face_encoding)
                )
                
                # If similarity is high enough, consider it the same person
                if similarity > 0.7:  # Threshold for same person
                    similar_faces.append(face)
                    
            except Exception as e:
                print(f"Error comparing faces: {e}")
                continue
        
        return similar_faces
    
    async def search_faces_by_photo(
        self,
        event_id: int,
        search_image: UploadFile,
        customer_id: Optional[int] = None,
        session_id: Optional[str] = None,
        similarity_threshold: float = 0.6,
        max_results: int = 50
    ) -> FaceSearch:
        """Search for faces using uploaded photo"""
        
        # Upload search image to temporary location
        search_image_path = await self._upload_search_image(search_image, event_id)
        
        # Extract face encoding from search image
        search_encoding = await self._extract_face_encoding(search_image_path)
        
        if not search_encoding:
            raise ValueError("No face detected in search image")
        
        # Create face search record
        search = FaceSearch(
            customer_id=customer_id,
            event_id=event_id,
            search_image_path=search_image_path,
            search_encoding=json.dumps(search_encoding),
            similarity_threshold=similarity_threshold,
            max_results=max_results,
            session_id=session_id or str(uuid.uuid4())
        )
        
        self.db.add(search)
        self.db.flush()
        
        # Start search processing
        await self._process_face_search(search.id)
        
        self.db.commit()
        return search
    
    async def _upload_search_image(self, search_image: UploadFile, event_id: int) -> str:
        """Upload search image to temporary storage"""
        # Create unique filename
        file_extension = search_image.filename.split('.')[-1].lower()
        unique_filename = f"search_{uuid.uuid4()}.{file_extension}"
        
        # Upload to searches bucket
        bucket_name = f"{settings.MINIO_BUCKET_PREFIX}searches"
        object_name = f"{event_id}/{unique_filename}"
        
        try:
            self.storage_service.client.put_object(
                bucket_name=bucket_name,
                object_name=object_name,
                data=search_image.file,
                length=search_image.size,
                content_type=search_image.content_type
            )
            
            return f"{bucket_name}/{object_name}"
            
        except Exception as e:
            raise Exception(f"Failed to upload search image: {e}")
    
    async def _extract_face_encoding(self, image_path: str) -> Optional[List[float]]:
        """Extract face encoding from image using AI service"""
        # Get temporary URL for the search image
        image_url = self.storage_service.get_download_url_from_path(image_path, expires=300)
        
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    self.ai_process_url,
                    json={
                        "image_url": image_url,
                        "extract_encoding_only": True,
                        "min_confidence": 0.5
                    },
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    result = response.json()
                    faces = result.get("faces", [])
                    
                    if faces:
                        # Return the best quality face encoding
                        best_face = max(faces, key=lambda f: f.get("confidence", 0))
                        return best_face.get("encoding")
                
                return None
                
            except Exception as e:
                print(f"Error extracting face encoding: {e}")
                return None
    
    async def _process_face_search(self, search_id: int):
        """Process face search and find matching faces"""
        search = self.db.query(FaceSearch).filter(FaceSearch.id == search_id).first()
        
        try:
            search.search_status = FaceDetectionStatus.PROCESSING
            self.db.commit()
            
            search_encoding = np.array(json.loads(search.search_encoding))
            
            # Get all faces from the event
            faces = self.db.query(Face).join(Photo).filter(
                Photo.event_id == search.event_id,
                Photo.approval_status == "approved",
                Face.quality_score >= 0.5  # Minimum quality threshold
            ).all()
            
            results = []
            
            for face in faces:
                try:
                    face_encoding = np.array(json.loads(face.face_encoding))
                    
                    # Calculate similarity using cosine similarity
                    similarity = np.dot(search_encoding, face_encoding) / (
                        np.linalg.norm(search_encoding) * np.linalg.norm(face_encoding)
                    )
                    
                    # Calculate distance (Euclidean)
                    distance = np.linalg.norm(search_encoding - face_encoding)
                    
                    if similarity >= search.similarity_threshold:
                        results.append({
                            "face": face,
                            "similarity": similarity,
                            "distance": distance,
                            "confidence": face.confidence
                        })
                        
                except Exception as e:
                    print(f"Error comparing with face {face.id}: {e}")
                    continue
            
            # Sort by similarity (highest first)
            results.sort(key=lambda x: x["similarity"], reverse=True)
            
            # Limit results
            results = results[:search.max_results]
            
            # Save search results
            for i, result in enumerate(results):
                search_result = FaceSearchResult(
                    search_id=search.id,
                    photo_id=result["face"].photo_id,
                    face_id=result["face"].id,
                    similarity_score=result["similarity"],
                    confidence_score=result["confidence"],
                    distance_score=result["distance"],
                    face_bounding_box=result["face"].bounding_box,
                    rank_order=i + 1
                )
                
                self.db.add(search_result)
            
            # Update search status
            search.search_status = FaceDetectionStatus.COMPLETED
            search.total_matches = len(results)
            search.best_match_similarity = results[0]["similarity"] if results else 0
            search.completed_at = datetime.utcnow()
            search.processing_time_seconds = int(
                (search.completed_at - search.created_at).total_seconds()
            )
            
        except Exception as e:
            search.search_status = FaceDetectionStatus.FAILED
            search.error_message = str(e)
        
        finally:
            self.db.commit()
    
    def get_event_face_detection_status(self, event_id: int) -> Dict:
        """Get face detection status for an event"""
        event = self.db.query(Event).filter(Event.id == event_id).first()
        if not event:
            return {"status": "not_found"}
        
        # Get latest processing job
        job = self.db.query(FaceProcessingJob).filter(
            FaceProcessingJob.event_id == event_id,
            FaceProcessingJob.job_type == "detect_faces"
        ).order_by(FaceProcessingJob.created_at.desc()).first()
        
        # Count photos
        total_photos = self.db.query(Photo).filter(
            Photo.event_id == event_id,
            Photo.approval_status == "approved"
        ).count()
        
        processed_photos = self.db.query(Photo).filter(
            Photo.event_id == event_id,
            Photo.approval_status == "approved",
            Photo.face_detection_status.in_(["completed", "failed"])
        ).count()
        
        faces_detected = self.db.query(Face).join(Photo).filter(
            Photo.event_id == event_id
        ).count()
        
        status = "not_started"
        progress = 0
        estimated_completion = None
        
        if job:
            status = job.status.value
            progress = job.progress_percentage
            
            if job.status == FaceDetectionStatus.PROCESSING and job.started_at:
                elapsed = datetime.utcnow() - job.started_at
                if job.faces_processed > 0:
                    avg_time_per_photo = elapsed.total_seconds() / job.faces_processed
                    remaining_photos = total_photos - job.faces_processed
                    estimated_seconds = remaining_photos * avg_time_per_photo
                    estimated_completion = (datetime.utcnow() + timedelta(seconds=estimated_seconds)).isoformat()
        
        return {
            "status": status,
            "progress": progress,
            "faces_detected": faces_detected,
            "photos_processed": processed_photos,
            "total_photos": total_photos,
            "estimated_completion": estimated_completion
        }
    
    def get_event_face_analytics(self, event_id: int) -> Dict:
        """Get comprehensive face recognition analytics for an event"""
        
        # Basic counts
        total_faces = self.db.query(Face).join(Photo).filter(Photo.event_id == event_id).count()
        total_groups = self.db.query(FaceGroup).filter(FaceGroup.event_id == event_id).count()
        verified_groups = self.db.query(FaceGroup).filter(
            FaceGroup.event_id == event_id,
            FaceGroup.is_verified == True
        ).count()
        
        # Quality distribution
        quality_dist = self.db.query(
            Face.quality_rating,
            func.count(Face.id)
        ).join(Photo).filter(
            Photo.event_id == event_id
        ).group_by(Face.quality_rating).all()
        
        quality_distribution = {rating: count for rating, count in quality_dist}
        
        # Search analytics
        total_searches = self.db.query(FaceSearch).filter(FaceSearch.event_id == event_id).count()
        successful_searches = self.db.query(FaceSearch).filter(
            FaceSearch.event_id == event_id,
            FaceSearch.total_matches > 0
        ).count()
        
        search_success_rate = (successful_searches / total_searches * 100) if total_searches > 0 else 0
        
        # Average faces per photo
        photos_with_faces = self.db.query(Photo).filter(
            Photo.event_id == event_id,
            Photo.face_count > 0
        ).count()
        
        avg_faces_per_photo = total_faces / photos_with_faces if photos_with_faces > 0 else 0
        
        # Popular search times (last 30 days)
        search_times = self.db.query(
            func.extract('hour', FaceSearch.created_at).label('hour'),
            func.count(FaceSearch.id).label('count')
        ).filter(
            FaceSearch.event_id == event_id,
            FaceSearch.created_at >= datetime.utcnow() - timedelta(days=30)
        ).group_by('hour').all()
        
        popular_search_times = {int(hour): count for hour, count in search_times}
        
        return {
            "total_faces": total_faces,
            "total_groups": total_groups,
            "verified_groups": verified_groups,
            "avg_faces_per_photo": round(avg_faces_per_photo, 2),
            "quality_distribution": quality_distribution,
            "total_searches": total_searches,
            "successful_searches": successful_searches,
            "search_success_rate": round(search_success_rate, 2),
            "popular_search_times": popular_search_times
        }
```

---

## üì± **Customer Face Search Frontend Integration**

### **app/api/public.py - Public APIs for Customers**
```python
from fastapi import APIRouter, Depends, HTTPException, Request, UploadFile, File
from fastapi.responses import HTMLResponse
from sqlalchemy.orm import Session
from app.database import get_db
from app.services.face_recognition_service import FaceRecognitionService
from app.models.event import Event
import uuid

router = APIRouter()

@router.get("/events/{event_id}/search", response_class=HTMLResponse)
async def face_search_page(
    event_id: int,
    db: Session = Depends(get_db)
):
    """Serve face search page for customers"""
    event = db.query(Event).filter(
        Event.id == event_id,
        Event.sales_enabled == True
    ).first()
    
    if not event:
        raise HTTPException(status_code=404, detail="Event not found or not available")
    
    # Return simple HTML page for face search
    return f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Find Your Photos - {event.name}</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {{ font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }}
            .upload-area {{ border: 2px dashed #ccc; padding: 40px; text-align: center; margin: 20px 0; }}
            .upload-area:hover {{ border-color: #007bff; }}
            .results {{ display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }}
            .photo-result {{ border: 1px solid #ddd; padding: 10px; text-align: center; }}
            .photo-result img {{ width: 100%; height: 150px; object-fit: cover; }}
            .similarity {{ color: #007bff; font-weight: bold; }}
        </style>
    </head>
    <body>
        <h1>Find Your Photos</h1>
        <h2>{event.name}</h2>
        <p>Upload a clear photo of your face to find photos of yourself from this event.</p>
        
        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <p>üì∏ Click here to upload your photo</p>
            <p><small>Accepted formats: JPG, PNG (Max 10MB)</small></p>
        </div>
        
        <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="uploadPhoto()">
        
        <div id="status"></div>
        <div id="results" class="results"></div>
        
        <script>
            let sessionId = '{uuid.uuid4()}';
            
            async function uploadPhoto() {{
                const fileInput = document.getElementById('fileInput');
                const file = fileInput.files[0];
                
                if (!file) return;
                
                const status = document.getElementById('status');
                status.innerHTML = '<p>üîç Searching for your photos...</p>';
                
                const formData = new FormData();
                formData.append('search_image', file);
                formData.append('session_id', sessionId);
                
                try {{
                    const response = await fetch('/api/face-recognition/search/{event_id}', {{
                        method: 'POST',
                        body: formData
                    }});
                    
                    const result = await response.json();
                    
                    if (response.ok) {{
                        pollResults(result.search_id);
                    }} else {{
                        status.innerHTML = '<p style="color: red;">‚ùå ' + result.detail + '</p>';
                    }}
                }} catch (error) {{
                    status.innerHTML = '<p style="color: red;">‚ùå Error uploading photo</p>';
                }}
            }}
            
            async function pollResults(searchId) {{
                const status = document.getElementById('status');
                const results = document.getElementById('results');
                
                try {{
                    const response = await fetch(`/api/face-recognition/search/${{searchId}}/results`);
                    const data = await response.json();
                    
                    if (data.status === 'processing') {{
                        setTimeout(() => pollResults(searchId), 2000);
                        return;
                    }}
                    
                    if (data.results.length === 0) {{
                        status.innerHTML = '<p>üòî No photos found. Try uploading a clearer photo of your face.</p>';
                        return;
                    }}
                    
                    status.innerHTML = `<p>‚úÖ Found ${{data.total_matches}} photos!</p>`;
                    
                    results.innerHTML = data.results.map(result => `
                        <div class="photo-result">
                            <img src="${{result.photo_thumbnail}}" alt="Photo">
                            <p class="similarity">${{Math.round(result.similarity_score * 100)}}% match</p>
                            <button onclick="addToCart(${{result.photo_id}})">Add to Cart</button>
                            <button onclick="provideFeedback(${{searchId}}, ${{result.photo_id}}, 'correct')">üëç</button>
                            <button onclick="provideFeedback(${{searchId}}, ${{result.photo_id}}, 'incorrect')">üëé</button>
                        </div>
                    `).join('');
                    
                }} catch (error) {{
                    status.innerHTML = '<p style="color: red;">‚ùå Error getting results</p>';
                }}
            }}
            
            async function addToCart(photoId) {{
                // Implement add to cart functionality
                alert('Photo added to cart! (Implement cart integration)');
            }}
            
            async function provideFeedback(searchId, photoId, feedback) {{
                try {{
                    await fetch(`/api/face-recognition/search/${{searchId}}/feedback`, {{
                        method: 'POST',
                        headers: {{ 'Content-Type': 'application/json' }},
                        body: JSON.stringify({{
                            photo_id: photoId,
                            feedback: feedback
                        }})
                    }});
                }} catch (error) {{
                    console.error('Error submitting feedback:', error);
                }}
            }}
        </script>
    </body>
    </html>
    """

@router.get("/events/{event_id}/info")
async def get_event_info(
    event_id: int,
    db: Session = Depends(get_db)
):
    """Get public event information"""
    event = db.query(Event).filter(
        Event.id == event_id,
        Event.sales_enabled == True
    ).first()
    
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    
    return {
        "id": event.id,
        "name": event.name,
        "description": event.description,
        "event_date": event.event_date.isoformat() if event.event_date else None,
        "location": event.location,
        "venue": event.venue,
        "total_photos": event.approved_photos,
        "face_search_available": event.face_detection_completed
    }
```

---

## üîß **Integration with Existing APIs**

### **Update app/main.py to include Face Recognition**
```python
from app.api import auth, events, photos, orders, payments, downloads, face_recognition, public

# Include all routers
app.include_router(auth.router, prefix="/api/auth", tags=["Authentication"])
app.include_router(events.router, prefix="/api/events", tags=["Events"])
app.include_router(photos.router, prefix="/api/photos", tags=["Photos"])
app.include_router(orders.router, prefix="/api/orders", tags=["Orders"])
app.include_router(payments.router, prefix="/api/payments", tags=["Payments"])
app.include_router(downloads.router, prefix="/api/downloads", tags=["Downloads"])
app.include_router(face_recognition.router, prefix="/api/face-recognition", tags=["Face Recognition"])
app.include_router(public.router, prefix="/api/public", tags=["Public APIs"])
```

### **Create Missing Schemas**

#### **app/schemas/face.py**
```python
from pydantic import BaseModel
from typing import Optional, List, Dict
from datetime import datetime

class FaceSearchCreate(BaseModel):
    similarity_threshold: float = 0.6
    max_results: int = 50

class FaceSearchResponse(BaseModel):
    id: int
    event_id: int
    total_matches: int
    best_match_similarity: Optional[float]
    search_status: str
    created_at: datetime
    completed_at: Optional[datetime]
    
    class Config:
        from_attributes = True

class FaceSearchResultResponse(BaseModel):
    photo_id: int
    similarity_score: float
    confidence_score: float
    rank_order: int
    photo_thumbnail: str
    photo_preview: str

class FaceGroupResponse(BaseModel):
    id: int
    event_id: int
    face_count: int
    avg_confidence: float
    is_verified: bool
    group_name: Optional[str]
    representative_face_id: Optional[int]
    created_at: datetime
    
    class Config:
        from_attributes = True

class FaceFeedback(BaseModel):
    feedback: str  # "correct", "incorrect", "unsure"
    notes: Optional[str] = None
```

---

## üöÄ **Setup and Deployment**

### **Update Database Migration**
```bash
# Create migration for face recognition models
alembic revision --autogenerate -m "Phase 2: Face Recognition System"
alembic upgrade head
```

### **Install Additional Dependencies**
```bash
# Add to requirements.txt
httpx==0.25.2
numpy==1.24.3
opencv-python==4.8.1.78
scikit-learn==1.3.2

# Install
pip install httpx numpy opencv-python scikit-learn
```

### **Environment Variables Update**
```bash
# Add to .env
# AI Face Recognition
AI_PROCESS_URL=http://10.0.0.11:8001/process_face
FACE_RECOGNITION_ENABLED=true
FACE_SIMILARITY_THRESHOLD=0.6
MAX_SEARCH_RESULTS=50

# Face Search Settings
FACE_SEARCH_CACHE_HOURS=24
MAX_SEARCH_IMAGE_SIZE_MB=10
SEARCH_RESULT_EXPIRES_HOURS=72
```

### **Test Face Recognition System**
```bash
# Start the enhanced API server
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# Test face detection
curl -X POST "http://localhost:8000/api/face-recognition/detect/event/1" \
  -H "Authorization: Bearer YOUR_ADMIN_TOKEN"

# Test public face search page
open http://localhost:8000/api/public/events/1/search
```

---

## ‚úÖ **Phase 2 Complete Features**

### **ü§ñ Face Recognition System:**
- ‚úÖ **Automated Face Detection** - Detect faces in all event photos
- ‚úÖ **Face Grouping** - Group similar faces automatically
- ‚úÖ **Quality Assessment** - Rate face quality (excellent/good/fair/poor)
- ‚úÖ **Admin Verification** - Manual verification of face groups

### **üîç Customer Face Search:**
- ‚úÖ **Photo Upload Search** - Customers upload selfie to find photos
- ‚úÖ **Similarity Matching** - Advanced face comparison algorithms
- ‚úÖ **Real-time Results** - Progressive search result display
- ‚úÖ **Feedback System** - Customers can rate search accuracy

### **üìä Analytics & Monitoring:**
- ‚úÖ **Detection Progress** - Real-time face detection status
- ‚úÖ **Search Analytics** - Success rates, popular times
- ‚úÖ **Quality Metrics** - Face detection confidence scores
- ‚úÖ **Performance Tracking** - Processing times and accuracy

### **üîß Technical Implementation:**
- ‚úÖ **External AI Integration** - Connect to face recognition service
- ‚úÖ **Efficient Storage** - Face encodings and metadata
- ‚úÖ **Background Processing** - Asynchronous face detection
- ‚úÖ **Public APIs** - Customer-facing search interface

**‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞:** Phase 2 Face Recognition Complete ‚úÖ  
**‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ:** Phase 3 Analytics & Admin Dashboard  
**‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:** Face search for customers, admin face management
